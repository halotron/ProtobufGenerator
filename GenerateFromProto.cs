using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Shell.Interop;

namespace Knacka.Se.ProtobufGenerator
{
    public class GenerateFromProto : ICanGenerateFromProto
    {
        private readonly string _protocPath;
        private readonly string _grpcPath;

        public GenerateFromProto(string protocPath, string grpcPath)
        {
            _protocPath = protocPath;
            _grpcPath = grpcPath;
        }
        

        public byte[] GenerateCsharpFromProto(string protoPath)
        {
            if (string.IsNullOrEmpty(_protocPath))
                return null;
            string indir = null;
            var args = new Dictionary<string, List<string>>();
            try
            {

                string infile = Path.GetFileName(protoPath);
                indir = Path.GetDirectoryName(protoPath);
                string outdir = GetTempDir();

                args.Add("csharp_out", new List<string>(new string[] { outdir }));
                args.Add("proto_path", new List<string>(new string[] { indir }));
                if (!string.IsNullOrEmpty(_grpcPath))
                {
                    args.Add("plugin", new List<string>(new string[] { "protoc-gen-grpc=" + _grpcPath }));
                    args.Add("grpc_out", new List<string>(new string[] { outdir }));
                }

                GetFileArguments(protoPath, ref args);

                var argsValue = WriteArgs(infile, ref args);

                Logger.Log("Running:   " + _protocPath + " " + argsValue + " in working directory:" + indir);

                string stderr = null;
                string stdout = null;
                var exitCode = RunProtoc(_protocPath, argsValue, indir, out stdout, out stderr);

                Logger.LogIf(() => exitCode != 0,
                    () => "exitcode was " + exitCode +
                          ". You might have a problem generating the code here. Command: " +
                          _protocPath + " " + argsValue + " in working directory: " + indir);

                Logger.LogIf(() => stdout.Length > 0, () => "stdout: " + stdout);
                Logger.LogIf(() => stderr.Length > 0, () => "stderr: " + stderr);

                if (!string.IsNullOrEmpty(stderr))
                {
                    throw new InvalidOperationException(stderr);
                }

                var files = Directory.GetFiles(outdir);
                if (files?.Any() == true)
                {
                    using (var ms = new MemoryStream())
                    using (var sw = new StreamWriter(ms))
                    {
                        sw.WriteLine($"// Generated by ProtobufGenerator {DateTime.Now:yyy-MM-dd HH:mm:ss}");
                        sw.WriteLine("\r\n#region Using statments\r\n");
                        foreach (var pass in Enumerable.Range(0, 2))
                        {
                            foreach (var file in files)
                            {
                                using (var fs = File.OpenRead(Path.Combine(outdir, file)))
                                using (var sr = new StreamReader(fs))
                                {
                                    if (pass == 1) sw.WriteLine($"\r\n#region File \"{Path.GetFileName(file)}\"\r\n");
                                    string line;
                                    var re = new Regex(@"^\s*using");
                                    while ((line = sr.ReadLine()) != null)
                                    {
                                        if (re.IsMatch(line) ^ pass == 1)
                                        {
                                            sw.WriteLine(line);
                                        }
                                    }

                                    if (pass == 1) sw.WriteLine("\r\n#endregion");
                                }
                            }

                            if (pass == 0) sw.WriteLine("\r\n#endregion");
                            sw.Flush();
                        }

                        CleanTempDir(outdir);
                        return ms.ToArray();
                    }
                }

                CleanTempDir(outdir);
            }
            catch (Exception e)
            {
                var msg = e.Message ?? e.ToString();
                Logger.Log("unhandled exception: " + msg);
            }
            finally
            {
                Logger.Log("Done with: " + _protocPath + " " + args + " in working directory:" + indir);
            }
            return null;
        }

        private static void CleanTempDir(string outdir)
        {
            try
            {
                Directory.Delete(outdir, true);
            }
            catch (Exception)
            {
                Logger.Log("warning: could not delete: " + outdir);
            }
        }

        private static string GetTempDir()
        {
            var tmpPath = Path.GetTempPath();
            var tries = 100;
            var r = new Random();
            while (tries-- > 0)
            {
                var path = Path.Combine(tmpPath, $"protoc-{r.Next():x}");
                if (!Directory.Exists(path))
                {
                    try
                    {
                        Directory.CreateDirectory(path);
                        return path;
                    }
                    catch (Exception x)
                    {
                        Logger.Log($"{x.GetType().Name}: {x.Message}, could not: create path \"{path}\"");
                        break;
                    }
                }
            }
            return null;
        }

        private static string CommentArgumentLineRegex = "^///? ?ProtobufGenerator-Arg:([^:]*)(:(.*))?";
        private void GetFileArguments(string protoPath, ref Dictionary<string, List<string>> args)
        {
            if (!File.Exists(protoPath))
            {
                return;
            }

            using (var fileReader = File.OpenRead(protoPath))
            using (var streamReader = new StreamReader(fileReader))
            {
                while(!streamReader.EndOfStream)
                {
                    var line = streamReader.ReadLine();
                    var match = Regex.Match(line, CommentArgumentLineRegex);
                    if (!match.Success)
                    {
                        continue;
                    }


                    var argName = match.Groups[1].Value;
                    var argValue = match.Groups[match.Groups.Count - 1].Value;

                    if (args.ContainsKey(argName))
                    {
                        args[argName].Add(argValue);
                    }
                    else
                    {
                        args.Add(argName, new List<string>(new string[] { argValue }));
                    }
                }
            }
        }

        private string WriteArgs(string protoFile, ref Dictionary<string, List<string>> args)
        {
            var sb = new StringBuilder();
            foreach (var kvp in args)
            {
                foreach (var argInstance in kvp.Value)
                {
                    sb.AppendFormat("--{0}={1} ", kvp.Key, argInstance);
                }
            }
            sb.AppendFormat(" {0}", protoFile);
            return sb.ToString();
        }

        static int RunProtoc(string path, string arguments, string workingDir, out string stdout, out string stderr)
        {
            using (var proc = new Process())
            {
                var psi = proc.StartInfo;
                psi.FileName = path;
                psi.Arguments = arguments;
                if (!string.IsNullOrEmpty(workingDir)) psi.WorkingDirectory = workingDir;
                psi.RedirectStandardError = psi.RedirectStandardOutput = true;
                psi.UseShellExecute = false;
                psi.CreateNoWindow = true;
                proc.Start();
                var stdoutTask = proc.StandardOutput.ReadToEndAsync();
                var stderrTask = proc.StandardError.ReadToEndAsync();
                if (!proc.WaitForExit(5000))
                {
                    try { proc.Kill(); } catch { }
                }
                var exitCode = proc.ExitCode;
                stderr = stdout = "";
                if (stdoutTask.Wait(1000)) stdout = stdoutTask.Result;
                if (stderrTask.Wait(1000)) stderr = stderrTask.Result;

                return exitCode;
            }
        }
    }
}

